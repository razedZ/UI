-- Основной код библиотеки (PizdecWare.lua)
local success, HttpService = pcall(game.GetService, game, "HttpService")
local success2, TweenService = pcall(game.GetService, game, "TweenService")
local success3, UserInputService = pcall(game.GetService, game, "UserInputService")

if not (success and success2 and success3) or not HttpService or not TweenService or not UserInputService then
    warn("Required services are not available. Script may not function fully.")
    return
end

local RunService = game:GetService("RunService")

-- Check for file I/O functions availability
local isFileAvailable = pcall(function() return isfile end)
local writeFileAvailable = pcall(function() return writefile end)

local PizdecWare = {}
PizdecWare.__index = PizdecWare

function PizdecWare:CreateWindow(guiName, infoText, saveConfig)
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = game:GetService("CoreGui")
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.Name = guiName

    -- Main window frame (Layer 1) - initially transparent
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Parent = ScreenGui
    MainFrame.BackgroundColor3 = Color3.fromRGB(19, 21, 25)
    MainFrame.BorderSizePixel = 0
    MainFrame.Position = UDim2.new(0.032, 0, 0.195, 0)
    MainFrame.Size = UDim2.new(0, 630, 0, 460)
    MainFrame.BackgroundTransparency = 1
    MainFrame.Active = true
    MainFrame.ZIndex = 1

    local UICorner = Instance.new("UICorner")
    UICorner.Parent = MainFrame

    -- Improved dragging functionality
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    MainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    MainFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)

    -- Logo with P and W letters
    local Logo = Instance.new("Frame")
    Logo.Name = "Logo"
    Logo.Parent = MainFrame
    Logo.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
    Logo.Size = UDim2.new(0, 25, 0, 25)
    Logo.Position = UDim2.new(0.022, 0, 0.031, 0)
    Logo.ZIndex = 3
    Logo.BackgroundTransparency = 1

    local UICorner_17 = Instance.new("UICorner")
    UICorner_17.Parent = Logo

    -- W letter
    local W = Instance.new("TextLabel")
    W.Name = "W"
    W.Parent = Logo
    W.BackgroundTransparency = 1
    W.Position = UDim2.new(0.282, 0, 0.76, 0)
    W.Size = UDim2.new(0, 23, 0, -14)
    W.ZIndex = 4
    W.Font = Enum.Font.SourceSansBold
    W.Text = "W"
    W.TextColor3 = Color3.fromRGB(0, 0, 0)
    W.TextSize = 20
    W.TextTransparency = 1

    -- P letter
    local P = Instance.new("TextLabel")
    P.Name = "P"
    P.Parent = Logo
    P.BackgroundTransparency = 1
    P.Position = UDim2.new(-0.304, 0, 0.76, 0)
    P.Size = UDim2.new(0, 27, 0, -14)
    P.ZIndex = 4
    P.Font = Enum.Font.SourceSansBold
    P.Text = "P"
    P.TextColor3 = Color3.fromRGB(255, 255, 255)
    P.TextSize = 20
    P.TextTransparency = 1

    -- PizdecWare label
    local PizdecWareLabel = Instance.new("TextLabel")
    PizdecWareLabel.Name = "PizdecWare"
    PizdecWareLabel.Parent = Logo
    PizdecWareLabel.BackgroundTransparency = 1
    PizdecWareLabel.Position = UDim2.new(2.2, 0, 1.3, 0)
    PizdecWareLabel.Size = UDim2.new(0, 60, 0, -41)
    PizdecWareLabel.Font = Enum.Font.SourceSansBold
    PizdecWareLabel.Text = "PizdecWare"
    PizdecWareLabel.TextColor3 = Color3.fromRGB(150, 17, 255)
    PizdecWareLabel.TextSize = 25
    PizdecWareLabel.TextTransparency = 1

    local Info = Instance.new("TextLabel")
    Info.Name = "Info"
    Info.Parent = MainFrame
    Info.BackgroundTransparency = 1
    Info.Position = UDim2.new(0.054, 0, 0.083, 0)
    Info.Size = UDim2.new(0, 116, 0, 10)
    Info.Font = Enum.Font.SourceSansBold
    Info.Text = infoText or ""
    Info.TextColor3 = Color3.fromRGB(170, 176, 183)
    Info.TextSize = 10
    Info.TextXAlignment = Enum.TextXAlignment.Right
    Info.TextTransparency = 1

    -- Main container - initially transparent
    local ElementContainer = Instance.new("ScrollingFrame")
    ElementContainer.Name = "ElementContainer"
    ElementContainer.Parent = MainFrame
    ElementContainer.BackgroundColor3 = Color3.fromRGB(23, 24, 28)
    ElementContainer.Position = UDim2.new(0.259, 0, 0.116, 0)
    ElementContainer.Size = UDim2.new(0, 460, 0, 400)
    ElementContainer.ZIndex = 1
    ElementContainer.BackgroundTransparency = 1
    ElementContainer.ScrollBarThickness = 8
    ElementContainer.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    ElementContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    ElementContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.Parent = ElementContainer

    local UIStroke = Instance.new("UIStroke")
    UIStroke.Parent = ElementContainer
    UIStroke.Color = Color3.fromRGB(0, 0, 0)
    UIStroke.Thickness = 1
    UIStroke.Transparency = 0.8

    -- Section containers
    local LeftContainer = Instance.new("Frame")
    LeftContainer.Name = "LeftContainer"
    LeftContainer.Parent = ElementContainer
    LeftContainer.BackgroundTransparency = 1
    LeftContainer.Position = UDim2.new(0, 20, 0, 20)
    LeftContainer.Size = UDim2.new(0.5, -30, 1, -40)

    local RightContainer = Instance.new("Frame")
    RightContainer.Name = "RightContainer"
    RightContainer.Parent = ElementContainer
    RightContainer.BackgroundTransparency = 1
    RightContainer.Position = UDim2.new(0.5, 10, 0, 20)
    RightContainer.Size = UDim2.new(0.5, -30, 1, -40)

    -- Fade in animation function
    local function fadeIn(element)
        if not TweenService then return end
        local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
        
        if element:IsA("TextLabel") or element:IsA("TextButton") then
            local tween = TweenService:Create(element, tweenInfo, {TextTransparency = 0})
            tween:Play()
        elseif element:IsA("ImageLabel") or element:IsA("ImageButton") then
            local tween = TweenService:Create(element, tweenInfo, {ImageTransparency = 0})
            tween:Play()
        elseif element:IsA("Frame") and element.Name:find("Toggle_") then
            return
        else
            local tween = TweenService:Create(element, tweenInfo, {BackgroundTransparency = 0})
            tween:Play()
        end
    end

    -- Create window instance to return
    local windowInstance = setmetatable({
        _tabZone = nil,
        _selectedTab = nil,
        _currentTab = nil,
        _tabSections = {},
        _initialized = false,
        _leftSections = {},
        _rightSections = {},
        _elementContainer = ElementContainer,
        _sectionStates = {},
        _toggleElements = {},
        _dropdownElements = {},
        _inputElements = {},
        _bindElements = {},
        _sliderElements = {},
        _saveConfig = saveConfig or { enabled = false, fileName = "PizdecWareSettings" },
        _savedToggles = {},
        _savedDropdowns = {},
        _savedInputs = {},
        _savedBinds = {},
        _savedSliders = {},
        _openDropdowns = {},
        _heartbeatConnection = nil
    }, PizdecWare)

    -- Load saved toggles and dropdowns
    if windowInstance._saveConfig.enabled and HttpService and isFileAvailable and writeFileAvailable then
        local success, savedData = pcall(function()
            if not isfile(windowInstance._saveConfig.fileName..".json") then
                return {}
            end
            local data = HttpService:JSONDecode(readfile(windowInstance._saveConfig.fileName..".json")) or {}
            return data
        end)
        
        if success and savedData then
            windowInstance._savedToggles = savedData.toggles or {}
            windowInstance._savedDropdowns = savedData.dropdowns or {}
            windowInstance._savedInputs = savedData.inputs or {}
            windowInstance._savedBinds = savedData.binds or {}
            windowInstance._savedSliders = savedData.sliders or {}
        else
            warn("Failed to load saved configuration. File I/O may be restricted.")
        end
    end

    -- Function to save toggle state
    local function saveToggleState(window, toggleName, state)
        if not window._saveConfig.enabled or not HttpService or not writeFileAvailable then return end
        
        window._savedToggles[toggleName] = state
        
        pcall(function()
            local data = {
                toggles = window._savedToggles,
                dropdowns = window._savedDropdowns,
                inputs = window._savedInputs,
                binds = window._savedBinds,
                sliders = window._savedSliders
            }
            writefile(window._saveConfig.fileName..".json", HttpService:JSONEncode(data))
        end)
    end

    -- Function to load toggle state
    local function loadToggleState(window, toggleName)
        if not window._saveConfig.enabled or not window._savedToggles then return nil end
        return window._savedToggles[toggleName]
    end

    -- Function to save dropdown state
    local function saveDropdownState(window, dropdownName, value)
        if not window._saveConfig.enabled or not HttpService or not writeFileAvailable then return end
        
        window._savedDropdowns[dropdownName] = value
        
        pcall(function()
            local data = {
                toggles = window._savedToggles,
                dropdowns = window._savedDropdowns,
                inputs = window._savedInputs,
                binds = window._savedBinds,
                sliders = window._savedSliders
            }
            writefile(window._saveConfig.fileName..".json", HttpService:JSONEncode(data))
        end)
    end

    -- Function to load dropdown state
    local function loadDropdownState(window, dropdownName)
        if not window._saveConfig.enabled or not window._savedDropdowns then return nil end
        return window._savedDropdowns[dropdownName]
    end

    -- Function to save input state
    local function saveInputState(window, inputName, value)
        if not window._saveConfig.enabled or not HttpService or not writeFileAvailable then return end
        
        window._savedInputs[inputName] = value
        
        pcall(function()
            local data = {
                toggles = window._savedToggles,
                dropdowns = window._savedDropdowns,
                inputs = window._savedInputs,
                binds = window._savedBinds,
                sliders = window._savedSliders
            }
            writefile(window._saveConfig.fileName..".json", HttpService:JSONEncode(data))
        end)
    end

    -- Function to load input state
    local function loadInputState(window, inputName)
        if not window._saveConfig.enabled or not window._savedInputs then return nil end
        return window._savedInputs[inputName]
    end

    -- Function to save bind state
    local function saveBindState(window, bindName, value)
        if not window._saveConfig.enabled or not HttpService or not writeFileAvailable then return end
        
        window._savedBinds[bindName] = value
        
        pcall(function()
            local data = {
                toggles = window._savedToggles,
                dropdowns = window._savedDropdowns,
                inputs = window._savedInputs,
                binds = window._savedBinds,
                sliders = window._savedSliders
            }
            writefile(window._saveConfig.fileName..".json", HttpService:JSONEncode(data))
        end)
    end

    -- Function to load bind state
    local function loadBindState(window, bindName)
        if not window._saveConfig.enabled or not window._savedBinds then return nil end
        return window._savedBinds[bindName]
    end

    -- Function to save slider state
    local function saveSliderState(window, sliderName, value)
        if not window._saveConfig.enabled or not HttpService or not writeFileAvailable then return end
        
        window._savedSliders[sliderName] = value
        
        pcall(function()
            local data = {
                toggles = window._savedToggles,
                dropdowns = window._savedDropdowns,
                inputs = window._savedInputs,
                binds = window._savedBinds,
                sliders = window._savedSliders
            }
            writefile(window._saveConfig.fileName..".json", HttpService:JSONEncode(data))
        end)
    end

    -- Function to load slider state
    local function loadSliderState(window, sliderName)
        if not window._saveConfig.enabled or not window._savedSliders then return nil end
        return window._savedSliders[sliderName]
    end

    local function getSortedElements(contentFrame)
        local elems = {}
        for _, child in ipairs(contentFrame:GetChildren()) do
            if child:IsA("Frame") and (child.Name:match("^Toggle_") or child.Name:match("^Dropdown_") or child.Name:match("^Input_") or child.Name:match("^Bind_") or child.Name:match("^Slider_")) then
                table.insert(elems, child)
            end
        end
        table.sort(elems, function(a, b)
            return a.Position.Y.Offset < b.Position.Y.Offset
        end)
        return elems
    end

    -- Function to update positions of all sections with synchronized animation
    local function updateSectionPositions(container, sections)
        local yOffset = 0
        local totalHeight = 0
        
        local targetPositions = {}
        for i, section in ipairs(sections) do
            if section.Visible then
                targetPositions[section] = UDim2.new(0, 0, 0, yOffset)
                
                if windowInstance._sectionStates[section] == false then
                    yOffset = yOffset + 30 + 20
                else
                    local contentFrame = section:FindFirstChild("ContentFrame")
                    local contentHeight = 0
                    if contentFrame then
                        local elements = getSortedElements(contentFrame)
                        local previous_type = nil
                        for j, element in ipairs(elements) do
                            local elem_type = element.Name:match("^Toggle_") and "toggle" or element.Name:match("^Dropdown_") and "dropdown" or element.Name:match("^Input_") and "input" or element.Name:match("^Bind_") and "bind" or "slider"
                            local spacing
                            if previous_type == nil then
                                spacing = 5
                            elseif previous_type == "toggle" and elem_type == "dropdown" then
                                spacing = 3 -- Расстояние между toggle и dropdown
                            elseif previous_type == "dropdown" and elem_type == "toggle" then
                                spacing = 5 -- Расстояние между dropdown и toggle
                            else
                                spacing = 5 -- Обычное расстояние для других комбинаций
                            end
                            contentHeight = contentHeight + spacing + element.Size.Y.Offset
                            previous_type = elem_type
                        end
                    end
                    local bottom_padding = 15
                    local sectionHeight = 30 + contentHeight + bottom_padding
                    yOffset = yOffset + sectionHeight + 20
                end
                totalHeight = yOffset
            end
        end
        
        for section, position in pairs(targetPositions) do
            local tween = TweenService:Create(
                section,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                {Position = position}
            )
            tween:Play()
        end
        
        windowInstance._elementContainer.CanvasSize = UDim2.new(0, 0, 0, totalHeight + 40)
    end

    -- Initialize UI elements
    coroutine.wrap(function()
        fadeIn(MainFrame)
        fadeIn(ElementContainer)
        wait(0.2)
        
        fadeIn(Logo)
        fadeIn(W)
        fadeIn(P)
        fadeIn(PizdecWareLabel)
        fadeIn(Info)
        wait(0.3)
        
        windowInstance._tabZone = Instance.new("Frame")
        windowInstance._tabZone.Name = "TabZone"
        windowInstance._tabZone.Parent = MainFrame
        windowInstance._tabZone.BackgroundTransparency = 1
        windowInstance._tabZone.Position = UDim2.new(0, 0, 0.116, 0)
        windowInstance._tabZone.Size = UDim2.new(0, 163, 0, 399)
        windowInstance._tabZone.ZIndex = 1

        local Tabs = Instance.new("TextLabel")
        Tabs.Name = "Tabs"
        Tabs.Parent = windowInstance._tabZone
        Tabs.BackgroundTransparency = 1
        Tabs.Position = UDim2.new(0.045, 0, 0, 0)
        Tabs.Size = UDim2.new(0, 50, 0, 20)
        Tabs.Font = Enum.Font.ArialBold
        Tabs.Text = "Tabs"
        Tabs.TextColor3 = Color3.fromRGB(147, 152, 156)
        Tabs.TextSize = 14
        Tabs.TextXAlignment = Enum.TextXAlignment.Left
        Tabs.ZIndex = 1
        fadeIn(Tabs)

        windowInstance._selectedTab = Instance.new("Frame")
        windowInstance._selectedTab.Name = "SelectedTab"
        windowInstance._selectedTab.Parent = windowInstance._tabZone
        windowInstance._selectedTab.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
        windowInstance._selectedTab.BackgroundTransparency = 0.6
        windowInstance._selectedTab.Position = UDim2.new(0, 0, 0, 23)
        windowInstance._selectedTab.Size = UDim2.new(0, 163, 0, 30)
        windowInstance._selectedTab.ZIndex = 2
        fadeIn(windowInstance._selectedTab)

        local UIGradient = Instance.new("UIGradient")
        UIGradient.Offset = Vector2.new(0, 1)
        UIGradient.Rotation = 0
        UIGradient.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0.00, 1.00), NumberSequenceKeypoint.new(0.01, 0.67), NumberSequenceKeypoint.new(1.00, 0.96)}
        UIGradient.Parent = windowInstance._selectedTab

        -- Fix gradient after animation
        local function fixGradient()
            windowInstance._selectedTab.BackgroundTransparency = 0.6
            UIGradient.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0.00, 1.00), NumberSequenceKeypoint.new(0.01, 0.67), NumberSequenceKeypoint.new(1.00, 0.96)}
        end

        local CloseButton = Instance.new("ImageButton")
        CloseButton.Name = "CloseButton"
        CloseButton.Parent = MainFrame
        CloseButton.BackgroundTransparency = 1
        CloseButton.Position = UDim2.new(0.949, 0, 0.017, 0)
        CloseButton.Size = UDim2.new(0, 25, 0, 25)
        CloseButton.Image = "rbxassetid://12653789995"
        CloseButton.ZIndex = 3
        fadeIn(CloseButton)
        CloseButton.MouseButton1Click:Connect(function()
            ScreenGui:Destroy()
        end)

        windowInstance._initialized = true
    end)()

    function windowInstance:CreateTab(visualName, imageId)
        while not self._initialized do wait() end
        
        local tabCount = 0
        for _, child in ipairs(self._tabZone:GetChildren()) do
            if child:IsA("TextLabel") and child.Name ~= "Tabs" then
                tabCount = tabCount + 1
            end
        end
        
        local initialOffset = (23 + (tabCount * 30)) / self._tabZone.AbsoluteSize.Y
        
        local tab = Instance.new("TextLabel")
        tab.Name = visualName
        tab.Parent = self._tabZone
        tab.BackgroundTransparency = 1
        tab.Position = UDim2.new(0.307, 0, initialOffset, 0)
        tab.Size = UDim2.new(0, 101, 0, 28)
        tab.Font = Enum.Font.SourceSansBold
        tab.Text = visualName
        tab.TextColor3 = Color3.fromRGB(147, 152, 156)
        tab.TextSize = 20
        tab.TextXAlignment = Enum.TextXAlignment.Left
        tab.ZIndex = 3
        fadeIn(tab)

        local image = Instance.new("ImageLabel")
        image.Name = "TabImage"
        image.Parent = tab
        image.BackgroundTransparency = 1
        image.Position = UDim2.new(-0.365, 0, 0.037, 0)
        image.Size = UDim2.new(0, 26, 0, 26)
        image.ZIndex = 3
        image.Image = "rbxassetid://" .. imageId
        image.ImageColor3 = Color3.fromRGB(147, 152, 156)
        fadeIn(image)

        local function selectTab()
            if not TweenService or not self._selectedTab then return end
            
            -- Close all open dropdowns when switching tabs
            for container, list in pairs(self._openDropdowns) do
                list.Visible = false
                list.Size = UDim2.new(0, 165, 0, 0)
                self._openDropdowns[container] = nil
            end
            
            local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
            
            for _, child in ipairs(self._tabZone:GetChildren()) do
                if child:IsA("TextLabel") and child ~= tab and child.Name ~= "Tabs" then
                    local childImage = child:FindFirstChild("TabImage")
                    TweenService:Create(child, tweenInfo, {TextColor3 = Color3.fromRGB(147, 152, 156)}):Play()
                    if childImage then
                        TweenService:Create(childImage, tweenInfo, {ImageColor3 = Color3.fromRGB(147, 152, 156)}):Play()
                    end
                end
            end
            
            TweenService:Create(tab, tweenInfo, {TextColor3 = Color3.fromRGB(150, 17, 255)}):Play()
            TweenService:Create(image, tweenInfo, {ImageColor3 = Color3.fromRGB(150, 17, 255)}):Play()

            local newPosition = UDim2.new(0, 0, tab.Position.Y.Scale, 0)
            local moveTween = TweenService:Create(
                self._selectedTab, 
                TweenInfo.new(0.1, Enum.EasingStyle.Linear),
                {Position = newPosition, BackgroundTransparency = 0.6}
            )
            moveTween:Play()
            
            moveTween.Completed:Connect(function()
                self._selectedTab.BackgroundTransparency = 0.6
                -- Fix gradient after animation
                local gradient = self._selectedTab:FindFirstChildOfClass("UIGradient")
                if gradient then
                    gradient.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0.00, 1.00), NumberSequenceKeypoint.new(0.01, 0.67), NumberSequenceKeypoint.new(1.00, 0.96)}
                end
            end)

            for tabName, sections in pairs(self._tabSections) do
                for _, section in ipairs(sections) do
                    section.Visible = (tabName == tab.Name)
                end
            end

            for _, sections in pairs({self._leftSections, self._rightSections}) do
                updateSectionPositions(nil, sections)
            end

            self._currentTab = tab
        end

        tab.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                selectTab()
            end
        end)

        image.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                selectTab()
            end
        end)

        if not self._currentTab then
            selectTab()
        end

        self._tabSections[tab.Name] = {}

        return tab
    end

    function windowInstance:CreateSection(sectionName, tab, side)
        if not tab then return nil end
        
        local container = (side == "left" and LeftContainer) or (side == "right" and RightContainer) or LeftContainer
        local sectionsList = (side == "left" and self._leftSections) or (side == "right" and self._rightSections) or self._leftSections
        
        local yOffset = 0
        for _, section in ipairs(sectionsList) do
            if section.Visible then
                if windowInstance._sectionStates[section] == false then
                    yOffset = yOffset + 30 + 20
                else
                    local contentFrame = section:FindFirstChild("ContentFrame")
                    local contentHeight = 0
                    if contentFrame then
                        local elements = getSortedElements(contentFrame)
                        local previous_type = nil
                        for j, element in ipairs(elements) do
                            local elem_type = element.Name:match("^Toggle_") and "toggle" or element.Name:match("^Dropdown_") and "dropdown" or element.Name:match("^Input_") and "input" or element.Name:match("^Bind_") and "bind" or "slider"
                            local spacing
                            if previous_type == nil then
                                spacing = 5
                            elseif previous_type == "toggle" and elem_type == "dropdown" then
                                spacing = 3 -- Расстояние между toggle и dropdown
                            elseif previous_type == "dropdown" and elem_type == "toggle" then
                                spacing = 5 -- Расстояние между dropdown и toggle
                            else
                                spacing = 2 -- Обычное расстояние для других комбинаций
                            end
                            contentHeight = contentHeight + spacing + element.Size.Y.Offset
                            previous_type = elem_type
                        end
                    end
                    local bottom_padding = 15
                    local sectionHeight = 30 + contentHeight + bottom_padding
                    yOffset = yOffset + sectionHeight + 20
                end
            end
        end

        local section = Instance.new("Frame")
        section.Name = sectionName
        section.Parent = container
        section.BackgroundColor3 = Color3.fromRGB(17, 19, 23)
        section.Position = UDim2.new(0, 0, 0, yOffset)
        section.Size = UDim2.new(1, 0, 0, 30)
        section.ZIndex = 4
        section.Visible = (tab == self._currentTab)
        section.ClipsDescendants = true
        fadeIn(section)

        windowInstance._sectionStates[section] = true

        local UICornerSection = Instance.new("UICorner")
        UICornerSection.CornerRadius = UDim.new(0, 3)
        UICornerSection.Parent = section

        local HeaderContainer = Instance.new("Frame")
        HeaderContainer.Name = "HeaderContainer"
        HeaderContainer.Parent = section
        HeaderContainer.BackgroundTransparency = 1
        HeaderContainer.Size = UDim2.new(1, 0, 0, 30)
        HeaderContainer.ZIndex = 5

        local SectionLabel = Instance.new("TextLabel")
        SectionLabel.Name = "Label"
        SectionLabel.Parent = HeaderContainer
        SectionLabel.BackgroundTransparency = 1
        SectionLabel.Position = UDim2.new(0.085, 0, 0.15, 0)
        SectionLabel.Size = UDim2.new(0, 100, 0, 20)
        SectionLabel.Font = Enum.Font.ArialBold
        SectionLabel.Text = sectionName
        SectionLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
        SectionLabel.TextSize = 14
        SectionLabel.TextXAlignment = Enum.TextXAlignment.Left
        SectionLabel.ZIndex = 5
        fadeIn(SectionLabel)

        local ShowSectionButton = Instance.new("TextButton")
        ShowSectionButton.Name = "ShowSection"
        ShowSectionButton.Parent = HeaderContainer
        ShowSectionButton.BackgroundTransparency = 1
        ShowSectionButton.Position = UDim2.new(0.86, 0, 0.15, 0)
        ShowSectionButton.Size = UDim2.new(0, 20, 0, 20)
        ShowSectionButton.Font = Enum.Font.SourceSans
        ShowSectionButton.Text = "▼"
        ShowSectionButton.TextColor3 = Color3.fromRGB(147, 152, 156)
        ShowSectionButton.TextSize = 14
        ShowSectionButton.ZIndex = 5
        fadeIn(ShowSectionButton)

        local SectionLine = Instance.new("Frame")
        SectionLine.Name = "Line"
        SectionLine.Parent = HeaderContainer
        SectionLine.BackgroundColor3 = Color3.fromRGB(66, 63, 71)
        SectionLine.Position = UDim2.new(0.045, 0, 1, 0)
        SectionLine.Size = UDim2.new(0.91, 0, 0, 1)
        SectionLine.ZIndex = 4
        fadeIn(SectionLine)

        local ContentFrame = Instance.new("Frame")
        ContentFrame.Name = "ContentFrame"
        ContentFrame.Parent = section
        ContentFrame.BackgroundColor3 = Color3.fromRGB(17, 19, 23)
        ContentFrame.BackgroundTransparency = 1
        ContentFrame.Position = UDim2.new(0, 0, 0, 31)
        ContentFrame.Size = UDim2.new(1, 0, 0, 0)
        ContentFrame.ZIndex = 4
        ContentFrame.ClipsDescendants = true

        local collapsedSize = UDim2.new(1, 0, 0, 30)

        local function toggleSection()
            if not TweenService then return end
            
            local isExpanded = windowInstance._sectionStates[section]
            windowInstance._sectionStates[section] = not isExpanded
            
            if not isExpanded then
                ShowSectionButton.Text = "▼"
                ContentFrame.BackgroundTransparency = 1
                
                for _, element in pairs(self._toggleElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = true
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._dropdownElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = true
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._inputElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = true
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._bindElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = true
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._sliderElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = true
                        element.BackgroundTransparency = 1
                    end
                end
                
                local contentHeight = 0
                local elements = getSortedElements(ContentFrame)
                local previous_type = nil
                for j, element in ipairs(elements) do
                    local elem_type = element.Name:match("^Toggle_") and "toggle" or element.Name:match("^Dropdown_") and "dropdown" or element.Name:match("^Input_") and "input" or element.Name:match("^Bind_") and "bind" or "slider"
                    local spacing
                    if previous_type == nil then
                        spacing = 5
                    elseif previous_type == "toggle" and elem_type == "dropdown" then
                        spacing = 3 -- Расстояние между toggle и dropdown
                    elseif previous_type == "dropdown" and elem_type == "toggle" then
                        spacing = 5 -- Расстояние между dropdown и toggle
                    else
                        spacing = 2 -- Обычное расстояние для других комбинаций
                    end
                    contentHeight = contentHeight + spacing + element.Size.Y.Offset
                    previous_type = elem_type
                end
                ContentFrame.Size = UDim2.new(1, 0, 0, contentHeight)
                
                local bottom_padding = 15
                local sizeTween = TweenService:Create(
                    section,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                    {Size = UDim2.new(1, 0, 0, 30 + contentHeight + bottom_padding)}
                )
                sizeTween:Play()
            else
                ShowSectionButton.Text = "▲"
                
                for _, element in pairs(self._toggleElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = false
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._dropdownElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = false
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._inputElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = false
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._bindElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = false
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._sliderElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = false
                        element.BackgroundTransparency = 1
                    end
                end
                
                for dropdownContainer, dropdownList in pairs(self._openDropdowns) do
                    if dropdownContainer:IsDescendantOf(section) then
                        dropdownList.Visible = false
                        dropdownList.Size = UDim2.new(0, 165, 0, 0)
                        self._openDropdowns[dropdownContainer] = nil
                    end
                end
                
                ContentFrame.Size = UDim2.new(1, 0, 0, 0)
                local sizeTween = TweenService:Create(
                    section,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                    {Size = collapsedSize}
                )
                sizeTween:Play()
            end
            
            updateSectionPositions(container, sectionsList)
        end

        ShowSectionButton.MouseButton1Click:Connect(toggleSection)

        if not self._tabSections[tab.Name] then
            self._tabSections[tab.Name] = {}
        end
        table.insert(self._tabSections[tab.Name], section)
        table.insert(sectionsList, section)
        
        updateSectionPositions(container, sectionsList)

        return section
    end

    -- New toggle creation function with simplified syntax
    function windowInstance:CreateToggle(params)
        if not params.section then return nil end
        
        local section = params.section
        local toggleName = params.name or ""
        local defaultValue = params.enable or false
        local save = params.save or false
        local callback = params.callback or function() end
        
        local ContentFrame = section:FindFirstChild("ContentFrame")
        if not ContentFrame then return nil end
        
        if save and self._saveConfig.enabled then
            local savedState = loadToggleState(self, toggleName)
            if savedState ~= nil then
                defaultValue = savedState
            end
        end
        
        local elements = getSortedElements(ContentFrame)
        local new_type = "toggle"
        local yOffset
        if #elements == 0 then
            yOffset = 5
        else
            local last = elements[#elements]
            local last_type = last.Name:match("^Toggle_") and "toggle" or "dropdown"
            local spacing
            if last_type == "toggle" and new_type == "dropdown" then
                spacing = 3 -- Расстояние между toggle и dropdown
            elseif last_type == "dropdown" and new_type == "toggle" then
                spacing = 8
            else
                spacing = 2 -- Обычное расстояние для других комбинаций
            end
            yOffset = last.Position.Y.Offset + last.Size.Y.Offset + spacing
        end

        local ToggleContainer = Instance.new("Frame")
        ToggleContainer.Name = "Toggle_" .. toggleName
        ToggleContainer.Parent = ContentFrame
        ToggleContainer.BackgroundTransparency = 1
        ToggleContainer.Size = UDim2.new(1, 0, 0, 30)
        ToggleContainer.Position = UDim2.new(0, 0, 0, yOffset)
        ToggleContainer.ZIndex = 5
        ToggleContainer.Visible = true

        local ToggleButton = Instance.new("TextButton")
        ToggleButton.Name = "Button"
        ToggleButton.Parent = ToggleContainer
        ToggleButton.BackgroundColor3 = defaultValue and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(24, 29, 32)
        ToggleButton.BorderSizePixel = 0
        ToggleButton.Position = UDim2.new(0.085, 0, 0.1, 0)
        ToggleButton.Size = UDim2.new(0, 20, 0, 20)
        ToggleButton.Text = ""
        ToggleButton.ZIndex = 6

        local UICornerToggle = Instance.new("UICorner")
        UICornerToggle.CornerRadius = UDim.new(0, 4)
        UICornerToggle.Parent = ToggleButton

        local Checkmark = Instance.new("TextLabel")
        Checkmark.Name = "Checkmark"
        Checkmark.Parent = ToggleButton
        Checkmark.BackgroundTransparency = 1
        Checkmark.Size = UDim2.new(1, 0, 1, 0)
        Checkmark.Text = "✔️"
        Checkmark.TextColor3 = Color3.fromRGB(24, 29, 32)
        Checkmark.TextSize = 10
        Checkmark.ZIndex = 7
        Checkmark.Visible = defaultValue

        local ToggleText = Instance.new("TextLabel")
        ToggleText.Name = "Text"
        ToggleText.Parent = ToggleContainer
        ToggleText.BackgroundTransparency = 1
        ToggleText.Position = UDim2.new(0.15, 20, 0.1, 0)
        ToggleText.Size = UDim2.new(0.85, -20, 0, 20)
        ToggleText.Font = Enum.Font.SourceSansBold
        ToggleText.Text = toggleName
        ToggleText.TextColor3 = Color3.fromRGB(147, 152, 156)
        ToggleText.TextSize = 17
        ToggleText.TextXAlignment = Enum.TextXAlignment.Left
        ToggleText.ZIndex = 6

        local isToggled = defaultValue or false
        
        ToggleButton.MouseButton1Click:Connect(function()
            isToggled = not isToggled
            
            if isToggled then
                ToggleButton.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
                Checkmark.Visible = true
            else
                ToggleButton.BackgroundColor3 = Color3.fromRGB(24, 29, 32)
                Checkmark.Visible = false
            end
            
            if save and self._saveConfig.enabled then
                saveToggleState(self, toggleName, isToggled)
            end
            
            callback(isToggled)
        end)
        
        table.insert(self._toggleElements, ToggleContainer)
        
        local sectionsList = table.find(self._leftSections, section) and self._leftSections or self._rightSections
        local container = sectionsList == self._leftSections and LeftContainer or RightContainer
        
        local contentHeight = 0
        local elements_updated = getSortedElements(ContentFrame)
        local previous_type = nil
        for j, element in ipairs(elements_updated) do
            local elem_type = element.Name:match("^Toggle_") and "toggle" or "dropdown"
            local spacing
            if previous_type == nil then
                spacing = 5
            elseif previous_type == "toggle" and elem_type == "dropdown" then
                spacing = 3 -- Расстояние между toggle и dropdown
            elseif previous_type == "dropdown" and elem_type == "toggle" then
                spacing = 5 -- Расстояние между dropdown и toggle
            else
                spacing = 2 -- Обычное расстояние для других комбинаций
            end
            contentHeight = contentHeight + spacing + element.Size.Y.Offset
            previous_type = elem_type
        end
        
        if windowInstance._sectionStates[section] then
            local bottom_padding = 15
            section.Size = UDim2.new(1, 0, 0, 30 + contentHeight + bottom_padding)
            ContentFrame.Size = UDim2.new(1, 0, 0, contentHeight)
        end
        
        updateSectionPositions(container, sectionsList)
        
        return {
            Set = function(self, value)
                isToggled = value
                
                if isToggled then
                    ToggleButton.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
                    Checkmark.Visible = true
                else
                    ToggleButton.BackgroundColor3 = Color3.fromRGB(24, 29, 32)
                    Checkmark.Visible = false
                end
                
                if save and windowInstance._saveConfig.enabled then
                    saveToggleState(windowInstance, toggleName, isToggled)
                end
                
                callback(isToggled)
            end,
            Get = function(self)
                return isToggled
            end
        }
    end

    -- New dropdown creation function with simplified syntax
    function windowInstance:CreateDropdown(params)
    -- Проверка параметров
    if not params or not params.section then 
        warn("CreateDropdown: Invalid parameters")
        return nil 
    end
    
    local section = params.section
    if not section or not section:IsA("Frame") then
        warn("CreateDropdown: Invalid section")
        return nil
    end
    
    local dropdownName = params.name or "Dropdown_"..tostring(math.random(1000,9999))
    local options = params.options or {}
    local defaultOption = params.default or nil
    local multi = params.multi or false
    local save = params.save or false
    local callback = params.callback or function() end
    
    local ContentFrame = section:FindFirstChild("ContentFrame")
    if not ContentFrame then
        warn("CreateDropdown: ContentFrame not found in section")
        return nil
    end
    
    -- Загрузка сохраненного значения
    if save and self._saveConfig and self._saveConfig.enabled then
        local success, savedState = pcall(function()
            return self:loadDropdownState(dropdownName)
        end)
        if success and savedState ~= nil then
            if multi then
                defaultOption = savedState
            else
                if table.find(options, savedState) then
                    defaultOption = savedState
                end
            end
        end
    end
    
    -- Функция для безопасного получения элементов
    local function getSafeSortedElements()
        local elements = {}
        for _, child in ipairs(ContentFrame:GetChildren()) do
            if child:IsA("Frame") and child.Name then
                if child.Name:match("^Toggle_") or child.Name:match("^Dropdown_") or child.Name:match("^Input_") or child.Name:match("^Bind_") then
                    table.insert(elements, child)
                end
            end
        end
        table.sort(elements, function(a, b)
            return (a.Position.Y.Offset or 0) < (b.Position.Y.Offset or 0)
        end)
        return elements
    end

    -- Расчет позиции нового элемента с увеличенным отступом для дропдаунов
    local elements = getSafeSortedElements()
    local yOffset = 5 -- Стандартный отступ для первого элемента
    
    if #elements > 0 then
        local lastElement = elements[#elements]
        if lastElement and lastElement.Position then
            local lastType = lastElement.Name:match("^Toggle_") and "toggle" or 
                           lastElement.Name:match("^Dropdown_") and "dropdown" or 
                           lastElement.Name:match("^Input_") and "input" or 
                           "bind"
            
            -- Увеличенные отступы
            local spacing = 5 -- Базовый отступ
            if lastType == "toggle" and "dropdown" then
                spacing = 3
            elseif lastType == "dropdown" and "dropdown" then
                spacing = 5 -- Увеличенный отступ между дропдаунами
            elseif lastType == "dropdown" and "toggle" then
                spacing = 5
            end
            
            yOffset = lastElement.Position.Y.Offset + lastElement.Size.Y.Offset + spacing
        end
    end

    -- Создание контейнера дропдауна
    local DropdownContainer = Instance.new("Frame")
    DropdownContainer.Name = "Dropdown_"..dropdownName
    DropdownContainer.Parent = ContentFrame
    DropdownContainer.BackgroundTransparency = 1
    DropdownContainer.Size = UDim2.new(1, 0, 0, 50)
    DropdownContainer.Position = UDim2.new(0, 0, 0, yOffset)
    DropdownContainer.ZIndex = 5
    DropdownContainer.Visible = true
    
    -- Label дропдауна
    local DropdownLabel = Instance.new("TextLabel")
    DropdownLabel.Name = "Label"
    DropdownLabel.Parent = DropdownContainer
    DropdownLabel.BackgroundTransparency = 1
    DropdownLabel.Position = UDim2.new(0.085, 0, 0, 0)
    DropdownLabel.Size = UDim2.new(0, 165, 0, 20)
    DropdownLabel.Font = Enum.Font.SourceSansBold
    DropdownLabel.Text = dropdownName
    DropdownLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
    DropdownLabel.TextSize = 15
    DropdownLabel.TextXAlignment = Enum.TextXAlignment.Left
    DropdownLabel.ZIndex = 6
    
    -- Кнопка дропдауна
    local DropdownButton = Instance.new("TextButton")
    DropdownButton.Name = "Button"
    DropdownButton.Parent = DropdownContainer
    DropdownButton.BackgroundColor3 = Color3.fromRGB(25, 28, 34)
    DropdownButton.BorderSizePixel = 0
    DropdownButton.Position = UDim2.new(0.085, 0, 0, 20)
    DropdownButton.Size = UDim2.new(0, 165, 0, 30)
    DropdownButton.Font = Enum.Font.SourceSans
    DropdownButton.Text = ""
    DropdownButton.TextColor3 = Color3.fromRGB(147, 152, 156)
    DropdownButton.TextSize = 14
    DropdownButton.ZIndex = 6
    
    local UICornerDropdown = Instance.new("UICorner")
    UICornerDropdown.CornerRadius = UDim.new(0, 4)
    UICornerDropdown.Parent = DropdownButton
    
    -- Текст выбранного значения
    local SelectedText = Instance.new("TextLabel")
    SelectedText.Name = "SelectedText"
    SelectedText.Parent = DropdownButton
    SelectedText.BackgroundTransparency = 1
    SelectedText.Position = UDim2.new(0.05, 0, 0, 0)
    SelectedText.Size = UDim2.new(0.9, 0, 1, 0)
    SelectedText.Font = Enum.Font.SourceSans
    SelectedText.Text = ""
    SelectedText.TextColor3 = Color3.fromRGB(147, 152, 156)
    SelectedText.TextSize = 14
    SelectedText.TextXAlignment = Enum.TextXAlignment.Left
    SelectedText.ZIndex = 7
    
    -- Список дропдауна
    local DropdownList = Instance.new("Frame")
    DropdownList.Name = "DropdownList_"..dropdownName
    DropdownList.Parent = self._elementContainer.Parent
    DropdownList.BackgroundColor3 = Color3.fromRGB(25, 28, 34)
    DropdownList.BorderSizePixel = 0
    DropdownList.Size = UDim2.new(0, 165, 0, 0)
    DropdownList.Visible = false
    DropdownList.ZIndex = 1000
    DropdownList.ClipsDescendants = true
    
    local UICornerList = Instance.new("UICorner")
    UICornerList.CornerRadius = UDim.new(0, 4)
    UICornerList.Parent = DropdownList
    
    local ScrollingFrame = Instance.new("ScrollingFrame")
    ScrollingFrame.Parent = DropdownList
    ScrollingFrame.Size = UDim2.new(1, 0, 1, 0)
    ScrollingFrame.BackgroundTransparency = 1
    ScrollingFrame.ScrollBarThickness = 5
    ScrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    
    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.Parent = ScrollingFrame
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    
    -- Логика выбора значений
    local selectedOptions = {}
    if multi then
        if type(defaultOption) == "table" then
            for _, option in ipairs(defaultOption) do
                if table.find(options, option) then
                    selectedOptions[option] = true
                end
            end
        end
    else
        if table.find(options, defaultOption) then
            selectedOptions[defaultOption] = true
        end
    end
    
    local function updateSelectedText()
        if multi then
            local count = 0
            for _ in pairs(selectedOptions) do
                count = count + 1
            end
            
            if count == 0 then
                SelectedText.Text = "None selected"
            elseif count == 1 then
                for option in pairs(selectedOptions) do
                    SelectedText.Text = option
                    break
                end
            else
                SelectedText.Text = count .. " selected"
            end
        else
            for option in pairs(selectedOptions) do
                SelectedText.Text = option
                return
            end
            SelectedText.Text = "Select option"
        end
    end
    
    local function createOptionButtons()
        for _, child in ipairs(ScrollingFrame:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end
        
        for _, option in ipairs(options) do
            local OptionButton = Instance.new("TextButton")
            OptionButton.Name = "Option_"..option
            OptionButton.Parent = ScrollingFrame
            OptionButton.BackgroundColor3 = Color3.fromRGB(25, 28, 34)
            OptionButton.BorderSizePixel = 0
            OptionButton.Size = UDim2.new(1, 0, 0, 20)
            OptionButton.Font = Enum.Font.SourceSans
            OptionButton.Text = option
            OptionButton.TextColor3 = selectedOptions[option] and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(147, 152, 156)
            OptionButton.TextSize = 14
            OptionButton.ZIndex = 1001
            
            OptionButton.MouseButton1Click:Connect(function()
                if multi then
                    if selectedOptions[option] then
                        selectedOptions[option] = nil
                    else
                        selectedOptions[option] = true
                    end
                    OptionButton.TextColor3 = selectedOptions[option] and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(147, 152, 156)
                else
                    for opt in pairs(selectedOptions) do
                        selectedOptions[opt] = nil
                    end
                    
                    selectedOptions[option] = true
                    
                    for _, btn in ipairs(ScrollingFrame:GetChildren()) do
                        if btn:IsA("TextButton") then
                            btn.TextColor3 = btn == OptionButton and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(147, 152, 156)
                        end
                    end
                    
                    DropdownList.Visible = false
                    DropdownList.Size = UDim2.new(0, 165, 0, 0)
                    self._openDropdowns[DropdownContainer] = nil
                end
                
                updateSelectedText()
                
                if save and self._saveConfig.enabled then
                    if multi then
                        local selected = {}
                        for opt in pairs(selectedOptions) do
                            table.insert(selected, opt)
                        end
                        self:saveDropdownState(dropdownName, selected)
                    else
                        for opt in pairs(selectedOptions) do
                            self:saveDropdownState(dropdownName, opt)
                            break
                        end
                    end
                end
                
                if callback then
                    pcall(callback, multi and (function()
                        local selected = {}
                        for opt in pairs(selectedOptions) do
                            table.insert(selected, opt)
                        end
                        return selected
                    end)() or next(selectedOptions))
                end
            end)
        end
        
        local optionCount = #options
        local maxHeight = math.min(4, optionCount) * 20
        ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, optionCount * 20)
    end
    
    createOptionButtons()
    updateSelectedText()
    
    -- Управление открытием/закрытием дропдауна
    local function toggleDropdown()
        local isDropdownOpen = DropdownList.Visible
        
        if isDropdownOpen then
            DropdownList.Visible = false
            DropdownList.Size = UDim2.new(0, 165, 0, 0)
            self._openDropdowns[DropdownContainer] = nil
        else
            -- Закрываем другие открытые дропдауны
            for container, list in pairs(self._openDropdowns) do
                list.Visible = false
                list.Size = UDim2.new(0, 165, 0, 0)
                self._openDropdowns[container] = nil
            end
            
            -- Открываем текущий
            local buttonPos = DropdownButton.AbsolutePosition
            local buttonSize = DropdownButton.AbsoluteSize
            local screenSize = self._elementContainer.Parent.AbsoluteSize
            
            local yPos = buttonPos.Y + buttonSize.Y
            local maxHeight = math.min(4, #options) * 20
            
            if yPos + maxHeight > screenSize.Y then
                yPos = buttonPos.Y - maxHeight
            end
            
            DropdownList.Position = UDim2.new(0, buttonPos.X, 0, yPos)
            DropdownList.Size = UDim2.new(0, 165, 0, maxHeight)
            DropdownList.Visible = true
            self._openDropdowns[DropdownContainer] = DropdownList
            
            if not self._heartbeatConnection then
                self._heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    for _, list in pairs(self._openDropdowns) do
                        local button = list:FindFirstAncestorOfClass("Frame"):FindFirstChild("Button")
                        if button then
                            local buttonPos = button.AbsolutePosition
                            local buttonSize = button.AbsoluteSize
                            local screenSize = ScreenGui.AbsoluteSize
                            
                            local yPos = buttonPos.Y + buttonSize.Y
                            local maxHeight = math.min(4, #dropdownContainer.options or 4) * 20
                            
                            if yPos + maxHeight > screenSize.Y then
                                yPos = buttonPos.Y - maxHeight
                            end
                            
                            list.Position = UDim2.new(0, buttonPos.X, 0, yPos)
                        end
                    end
                end)
            end
        end
    end
    
    DropdownButton.MouseButton1Click:Connect(toggleDropdown)
    
    -- Закрытие при клике вне дропдауна
    game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton1 and DropdownList.Visible then
            local mousePos = game:GetService("UserInputService"):GetMouseLocation()
            local absPos = DropdownList.AbsolutePosition
            local absSize = DropdownList.AbsoluteSize
            
            if not (mousePos.X >= absPos.X and mousePos.X <= absPos.X + absSize.X and
                   mousePos.Y >= absPos.Y and mousePos.Y <= absPos.Y + absSize.Y) then
                toggleDropdown()
            end
        end
    end)
    
    table.insert(self._dropdownElements, DropdownContainer)
    
    -- Обновление размеров секции
    local function updateSectionSize()
        local sectionsList = table.find(self._leftSections, section) and self._leftSections or self._rightSections
        local container = sectionsList == self._leftSections and LeftContainer or RightContainer
        
        local contentHeight = 0
        local elements = getSafeSortedElements()
        local previousType = nil
        
        for _, element in ipairs(elements) do
            local elemType = element.Name:match("^Toggle_") and "toggle" or 
                           element.Name:match("^Dropdown_") and "dropdown" or 
                           element.Name:match("^Input_") and "input" or 
                           "bind"
            
            local spacing = 5 -- Базовый отступ
            if previousType == "toggle" and elemType == "dropdown" then
                spacing = 3
            elseif previousType == "dropdown" and elemType == "toggle" then
                spacing = 5
            elseif previousType == "dropdown" and elemType == "dropdown" then
                spacing = 5 -- Увеличенный отступ между дропдаунами
            end
            
            contentHeight = contentHeight + spacing + element.Size.Y.Offset
            previousType = elemType
        end
        
        if self._sectionStates[section] then
            ContentFrame.Size = UDim2.new(1, 0, 0, contentHeight)
            section.Size = UDim2.new(1, 0, 0, 30 + contentHeight + 15)
        end
        
        updateSectionPositions(container, sectionsList)
    end
    
    task.defer(updateSectionSize)
    
    return {
        Set = function(_, value)
            if multi then
                for opt in pairs(selectedOptions) do
                    selectedOptions[opt] = nil
                end
                
                if type(value) == "table" then
                    for _, option in ipairs(value) do
                        if table.find(options, option) then
                            selectedOptions[option] = true
                        end
                    end
                end
            else
                for opt in pairs(selectedOptions) do
                    selectedOptions[opt] = nil
                end
                
                if table.find(options, value) then
                    selectedOptions[value] = true
                end
            end
            
            updateSelectedText()
            createOptionButtons()
            
            if save and self._saveConfig.enabled then
                if multi then
                    local selected = {}
                    for opt in pairs(selectedOptions) do
                        table.insert(selected, opt)
                    end
                    self:saveDropdownState(dropdownName, selected)
                else
                    for opt in pairs(selectedOptions) do
                        self:saveDropdownState(dropdownName, opt)
                        break
                    end
                end
            end
            
            if callback then
                pcall(callback, multi and (function()
                    local selected = {}
                    for opt in pairs(selectedOptions) do
                        table.insert(selected, opt)
                    end
                    return selected
                end)() or next(selectedOptions))
            end
        end,
        Get = function()
            if multi then
                local selected = {}
                for opt in pairs(selectedOptions) do
                    table.insert(selected, opt)
                end
                return selected
            else
                for opt in pairs(selectedOptions) do
                    return opt
                end
                return nil
            end
        end,
        UpdateOptions = function(_, newOptions)
            options = newOptions
            
            for opt in pairs(selectedOptions) do
                if not table.find(options, opt) then
                    selectedOptions[opt] = nil
                end
            end
            
            updateSelectedText()
            createOptionButtons()
        end
    }
end

    -- New slider creation function
function windowInstance:CreateSlider(params)
    -- Parameter validation
    if not params or not params.section then 
        warn("CreateSlider: Invalid parameters")
        return nil 
    end
    
    local section = params.section
    if not section or not section:IsA("Frame") then
        warn("CreateSlider: Invalid section")
        return nil
    end
    
    local sliderName = params.name or "Slider"
    local minValue = params.min or 0
    local maxValue = params.max or 100
    local defaultValue = params.default or math.floor((minValue + maxValue) / 2)
    local save = params.save or false
    local callback = params.callback or function() end
    local precise = params.precise or false
    
    -- Ensure min is less than max
    if minValue > maxValue then
        minValue, maxValue = maxValue, minValue
    end
    
    -- Clamp default value
    defaultValue = math.clamp(defaultValue, minValue, maxValue)
    
    local ContentFrame = section:FindFirstChild("ContentFrame")
    if not ContentFrame then
        warn("CreateSlider: ContentFrame not found in section")
        return nil
    end
    
    -- Load saved value
    if save and self._saveConfig.enabled then
        local success, savedState = pcall(function()
            return loadSliderState(self, sliderName)
        end)
        if success and savedState ~= nil then
            defaultValue = tonumber(savedState) or defaultValue
            defaultValue = math.clamp(defaultValue, minValue, maxValue)
        end
    end
    
    -- Calculate position for new element with exact dropdown-like spacing
    local elements = getSortedElements(ContentFrame)
    local yOffset = 5 -- Default offset for first element
    
    if #elements > 0 then
        local lastElement = elements[#elements]
        if lastElement and lastElement.Position then
            -- Use same spacing as dropdown (8 pixels)
            yOffset = lastElement.Position.Y.Offset + lastElement.Size.Y.Offset + 8
        end
    end

    -- Create container for Slider with exact dropdown-like dimensions
    local SliderContainer = Instance.new("Frame")
    SliderContainer.Name = "Slider_" .. sliderName
    SliderContainer.Parent = ContentFrame
    SliderContainer.BackgroundTransparency = 1
    SliderContainer.Size = UDim2.new(1, 0, 0, 50) -- Same height as dropdown
    SliderContainer.Position = UDim2.new(0, 0, 0, yOffset)
    SliderContainer.ZIndex = 5
    SliderContainer.Visible = true
    
    -- Slider name label with exact dropdown alignment
    local SliderLabel = Instance.new("TextLabel")
    SliderLabel.Name = "Label"
    SliderLabel.Parent = SliderContainer
    SliderLabel.BackgroundTransparency = 1
    SliderLabel.Position = UDim2.new(0.085, 0, 0, 0) -- 8.5% from left
    SliderLabel.Size = UDim2.new(0, 100, 0, 15) -- Same as dropdown
    SliderLabel.Font = Enum.Font.SourceSans
    SliderLabel.Text = sliderName
    SliderLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
    SliderLabel.TextSize = 12
    SliderLabel.TextXAlignment = Enum.TextXAlignment.Left
    SliderLabel.ZIndex = 6
    
    -- Slider track with exact dropdown button dimensions and position
    local SliderTrack = Instance.new("Frame")
    SliderTrack.Name = "Track"
    SliderTrack.Parent = SliderContainer
    SliderTrack.BackgroundColor3 = Color3.fromRGB(25, 28, 34) -- Same as dropdown
    SliderTrack.BorderSizePixel = 0
    SliderTrack.Position = UDim2.new(0.085, 0, 0, 15) -- Same as dropdown
    SliderTrack.Size = UDim2.new(0, 165, 0, 30) -- Exact dropdown width
    SliderTrack.ZIndex = 6
    
    local UICornerTrack = Instance.new("UICorner")
    UICornerTrack.CornerRadius = UDim.new(0, 4) -- Same as dropdown
    UICornerTrack.Parent = SliderTrack
    
    -- Slider fill
    local SliderFill = Instance.new("Frame")
    SliderFill.Name = "Fill"
    SliderFill.Parent = SliderTrack
    SliderFill.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
    SliderFill.BorderSizePixel = 0
    SliderFill.Size = UDim2.new(0, 0, 1, 0)
    SliderFill.ZIndex = 7
    
    local UICornerFill = Instance.new("UICorner")
    UICornerFill.CornerRadius = UDim.new(0, 4)
    UICornerFill.Parent = SliderFill
    
    -- Slider thumb (positioned inside track)
    local SliderThumb = Instance.new("TextButton")
    SliderThumb.Name = "Thumb"
    SliderThumb.Parent = SliderTrack
    SliderThumb.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
    SliderThumb.BorderSizePixel = 0
    SliderThumb.Size = UDim2.new(0, 16, 0, 16)
    SliderThumb.Position = UDim2.new(0, -8, 0.5, -8)
    SliderThumb.Text = ""
    SliderThumb.ZIndex = 8
    SliderThumb.AutoButtonColor = false
    
    local UICornerThumb = Instance.new("UICorner")
    UICornerThumb.CornerRadius = UDim.new(1, 0)
    UICornerThumb.Parent = SliderThumb
    
    -- Value label with exact dropdown text alignment
    local ValueLabel = Instance.new("TextLabel")
    ValueLabel.Name = "Value"
    ValueLabel.Parent = SliderTrack -- Parent to track for perfect alignment
    ValueLabel.BackgroundTransparency = 1
    ValueLabel.Position = UDim2.new(0.05, 0, 0, 0) -- 5% from left of track
    ValueLabel.Size = UDim2.new(0.9, 0, 1, 0) -- 90% width of track
    ValueLabel.Font = Enum.Font.SourceSans
    ValueLabel.Text = tostring(defaultValue)
    ValueLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
    ValueLabel.TextSize = 14
    ValueLabel.TextXAlignment = Enum.TextXAlignment.Right -- Right aligned in track
    ValueLabel.ZIndex = 7
    
    -- Calculate positions based on track dimensions
    local function getValueFromPosition(x)
        local trackWidth = SliderTrack.AbsoluteSize.X
        local relativePos = math.clamp(x - SliderTrack.AbsolutePosition.X, 0, trackWidth)
        local normalized = relativePos / trackWidth
        local value = minValue + (maxValue - minValue) * normalized
        return precise and value or math.floor(value + 0.5)
    end
    
    local function getPositionFromValue(value)
        local normalized = (value - minValue) / (maxValue - minValue)
        return normalized * SliderTrack.AbsoluteSize.X
    end
    
    local currentValue = defaultValue
    local isDragging = false
    
    -- Update visual elements based on current value
    local function updateSlider(value)
        currentValue = math.clamp(value, minValue, maxValue)
        local displayValue = precise and string.format("%.2f", currentValue) or tostring(math.floor(currentValue + 0.5))
        ValueLabel.Text = displayValue
        
        local fillWidth = getPositionFromValue(currentValue)
        SliderFill.Size = UDim2.new(0, fillWidth, 1, 0)
        SliderThumb.Position = UDim2.new(0, fillWidth - 8, 0.5, -8)
        
        if save and self._saveConfig.enabled then
            saveSliderState(self, sliderName, currentValue)
        end
        
        callback(currentValue)
    end
    
    -- Initialize slider
    updateSlider(defaultValue)
    
    -- Input handling with proper event connections
    local function onInputBegan(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDragging = true
            local mousePos = input.Position
            local newValue = getValueFromPosition(mousePos.X)
            updateSlider(newValue)
        end
    end
    
    local function onInputChanged(input)
        if isDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local newValue = getValueFromPosition(input.Position.X)
            updateSlider(newValue)
        end
    end
    
    local function onInputEnded(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDragging = false
        end
    end
    
    -- Connect events to track instead of thumb for better usability
    SliderTrack.InputBegan:Connect(onInputBegan)
    local moveConn = UserInputService.InputChanged:Connect(onInputChanged)
    local endConn = UserInputService.InputEnded:Connect(onInputEnded)
    
    -- Cleanup
    SliderContainer.Destroying:Connect(function()
        moveConn:Disconnect()
        endConn:Disconnect()
    end)
    
    table.insert(self._sliderElements, SliderContainer)

    -- Function to properly update section layout
    local function updateSectionLayout()
        local sectionsList = table.find(self._leftSections, section) and self._leftSections or self._rightSections
        local container = sectionsList == self._leftSections and LeftContainer or RightContainer
        
        -- Calculate total content height with proper spacing
        local contentHeight = 0
        local elements = getSortedElements(ContentFrame)
        
        for i, element in ipairs(elements) do
            if i > 1 then
                -- Add 8px spacing between elements (same as dropdown)
                contentHeight = contentHeight + 8
            end
            contentHeight = contentHeight + element.Size.Y.Offset
        end
        
        -- Update sizes
        if windowInstance._sectionStates[section] then
            ContentFrame.Size = UDim2.new(1, 0, 0, contentHeight)
            section.Size = UDim2.new(1, 0, 0, 30 + contentHeight + 15) -- Header + content + padding
        end
        
        updateSectionPositions(container, sectionsList)
    end
    
    -- Defer layout update to next frame
    task.defer(updateSectionLayout)
    
    return {
        Set = function(self, value)
            updateSlider(value)
        end,
        Get = function(self)
            return currentValue
        end,
        SetRange = function(self, newMin, newMax)
            if newMin and newMax then
                if newMin > newMax then
                    newMin, newMax = newMax, newMin
                end
                minValue = newMin
                maxValue = newMax
                updateSlider(math.clamp(currentValue, minValue, maxValue))
            end
        end
    }
end

    -- New input creation function with original style
   function windowInstance:CreateInput(params)
    -- Проверка параметров
    if not params or not params.section then 
        warn("CreateInput: Invalid parameters")
        return nil 
    end
    
    local section = params.section
    if not section or not section:IsA("Frame") then
        warn("CreateInput: Invalid section")
        return nil
    end
    
    local inputName = params.name or "Input"
    local defaultText = params.default or ""
    local save = params.save or false
    local callback = params.callback or function() end
    
    local ContentFrame = section:FindFirstChild("ContentFrame")
    if not ContentFrame then
        warn("CreateInput: ContentFrame not found in section")
        return nil
    end
    
    -- Загрузка сохраненного значения
    if save and self._saveConfig.enabled then
        local success, savedState = pcall(function()
            return loadInputState(self, inputName)
        end)
        if success and savedState ~= nil then
            defaultText = savedState
        end
    end
    
    -- Расчет позиции нового элемента
    local elements = getSortedElements(ContentFrame)
    local yOffset = 5 -- Стандартный отступ для первого элемента
    
    if #elements > 0 then
        local lastElement = elements[#elements]
        if lastElement and lastElement.Position then
            yOffset = lastElement.Position.Y.Offset + lastElement.Size.Y.Offset + 5
        end
    end

    -- Создаем контейнер для Input
    local InputContainer = Instance.new("Frame")
    InputContainer.Name = "Input_" .. inputName
    InputContainer.Parent = ContentFrame
    InputContainer.BackgroundTransparency = 1
    InputContainer.Size = UDim2.new(1, 0, 0, 50)
    InputContainer.Position = UDim2.new(0, 0, 0, yOffset)
    InputContainer.ZIndex = 5
    InputContainer.Visible = true
    
    -- Текст "Input" сверху
    local InputTopLabel = Instance.new("TextLabel")
    InputTopLabel.Name = "InputTopLabel"
    InputTopLabel.Parent = InputContainer
    InputTopLabel.BackgroundTransparency = 1
    InputTopLabel.Position = UDim2.new(0.085, 0, 0, 0)
    InputTopLabel.Size = UDim2.new(0, 50, 0, 15)
    InputTopLabel.Font = Enum.Font.SourceSans
    InputTopLabel.Text = "Input"
    InputTopLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
    InputTopLabel.TextSize = 12
    InputTopLabel.TextXAlignment = Enum.TextXAlignment.Center
    InputTopLabel.ZIndex = 6
    
    -- Основное поле ввода (ширина 50px)
    local InputFrame = Instance.new("TextButton")
    InputFrame.Name = "InputFrame"
    InputFrame.Parent = InputContainer
    InputFrame.BackgroundColor3 = Color3.fromRGB(25, 28, 34)
    InputFrame.BorderSizePixel = 0
    InputFrame.Position = UDim2.new(0.085, 0, 0, 15)
    InputFrame.Size = UDim2.new(0, 50, 0, 30)
    InputFrame.AutoButtonColor = false
    InputFrame.Text = ""
    InputFrame.ZIndex = 6
    
    local UICornerInput = Instance.new("UICorner")
    UICornerInput.CornerRadius = UDim.new(0, 4)
    UICornerInput.Parent = InputFrame
    
    -- Текст внутри инпута
    local InputTextLabel = Instance.new("TextLabel")
    InputTextLabel.Name = "InputText"
    InputTextLabel.Parent = InputFrame
    InputTextLabel.BackgroundTransparency = 1
    InputTextLabel.Size = UDim2.new(1, 0, 1, 0)
    InputTextLabel.Font = Enum.Font.SourceSans
    InputTextLabel.Text = defaultText
    InputTextLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
    InputTextLabel.TextSize = 14
    InputTextLabel.TextXAlignment = Enum.TextXAlignment.Center
    InputTextLabel.ZIndex = 7
    InputTextLabel.ClipsDescendants = true
    
    -- Название инпута (с отступом 10px от InputFrame)
    local InputNameLabel = Instance.new("TextLabel")
    InputNameLabel.Name = "InputName"
    InputNameLabel.Parent = InputContainer
    InputNameLabel.BackgroundTransparency = 1
    InputNameLabel.Position = UDim2.new(0.085, 60, 0, 15) -- 50 (ширина) + 10 (отступ)
    InputNameLabel.Size = UDim2.new(0, 100, 0, 30)
    InputNameLabel.Font = Enum.Font.SourceSansBold
    InputNameLabel.Text = inputName
    InputNameLabel.TextColor3 = Color3.fromRGB(147, 152, 156) -- Явный цвет
    InputNameLabel.TextTransparency = 0 -- Полная непрозрачность
    InputNameLabel.TextSize = 15
    InputNameLabel.TextXAlignment = Enum.TextXAlignment.Left
    InputNameLabel.ZIndex = 6
    
    local currentText = defaultText
    
    local function updateText()
        InputTextLabel.Text = currentText
        
        if save and self._saveConfig.enabled then
            pcall(function()
                saveInputState(self, inputName, currentText)
            end)
        end
        
        if callback then
            pcall(callback, currentText)
        end
    end
    
    InputFrame.MouseButton1Click:Connect(function()
        local inputBox = Instance.new("TextBox")
        inputBox.Name = "InputBox"
        inputBox.Parent = InputFrame
        inputBox.BackgroundTransparency = 1
        inputBox.Size = UDim2.new(1, 0, 1, 0)
        inputBox.Font = Enum.Font.SourceSans
        inputBox.Text = currentText
        inputBox.TextColor3 = Color3.fromRGB(147, 152, 156)
        inputBox.TextSize = 14
        inputBox.TextXAlignment = Enum.TextXAlignment.Center
        inputBox.ZIndex = 8
        inputBox.ClearTextOnFocus = false
        inputBox.PlaceholderText = "Type..."
        inputBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
        
        InputTextLabel.Visible = false
        
        inputBox.FocusLost:Connect(function(enterPressed)
            currentText = inputBox.Text
            inputBox:Destroy()
            InputTextLabel.Visible = true
            updateText()
        end)
        
        inputBox:CaptureFocus()
    end)
    
    updateText()
    
    table.insert(self._inputElements, InputContainer)

    -- Обновление размеров секции
    task.defer(function()
        local currentElements = getSortedElements(ContentFrame)
        local totalHeight = 0
        
        if #currentElements > 0 then
            local lastElement = currentElements[#currentElements]
            totalHeight = lastElement.Position.Y.Offset + lastElement.Size.Y.Offset
        end
        
        if windowInstance._sectionStates[section] then
            ContentFrame.Size = UDim2.new(1, 0, 0, totalHeight + 5)
            section.Size = UDim2.new(1, 0, 0, 30 + totalHeight + 15)
        end
        
        local sectionsList = table.find(self._leftSections, section) and self._leftSections or self._rightSections
        local container = sectionsList == self._leftSections and LeftContainer or RightContainer
        updateSectionPositions(container, sectionsList)
    end)
    
    return {
        Set = function(self, value)
            currentText = tostring(value)
            updateText()
        end,
        Get = function(self)
            return currentText
        end
    }
end

    -- New bind creation function (similar to input but for keybinds)
    function windowInstance:CreateBind(params)
        -- Parameter validation
        if not params or not params.section then 
            warn("CreateBind: Invalid parameters")
            return nil 
        end
        
        local section = params.section
        if not section or not section:IsA("Frame") then
            warn("CreateBind: Invalid section")
            return nil
        end
        
        local bindName = params.name or "Bind"
        local defaultKey = params.default or nil
        local save = params.save or false
        local callback = params.callback or function() end
        
        local ContentFrame = section:FindFirstChild("ContentFrame")
        if not ContentFrame then
            warn("CreateBind: ContentFrame not found in section")
            return nil
        end
        
        -- Convert string key to Enum if needed
        if type(defaultKey) == "string" then
            defaultKey = Enum.KeyCode[defaultKey:upper()] or nil
        end
        
        -- Load saved value
        if save and self._saveConfig.enabled then
            local success, savedState = pcall(function()
                return loadBindState(self, bindName)
            end)
            if success and savedState ~= nil then
                if type(savedState) == "string" then
                    defaultKey = Enum.KeyCode[savedState:upper()] or defaultKey
                else
                    defaultKey = savedState
                end
            end
        end
        
        -- Calculate position for new element
        local elements = getSortedElements(ContentFrame)
        local yOffset = 5 -- Default offset for first element
        
        if #elements > 0 then
            local lastElement = elements[#elements]
            if lastElement and lastElement.Position then
                yOffset = lastElement.Position.Y.Offset + lastElement.Size.Y.Offset + 5
            end
        end

        -- Create container for Bind
        local BindContainer = Instance.new("Frame")
        BindContainer.Name = "Bind_" .. bindName
        BindContainer.Parent = ContentFrame
        BindContainer.BackgroundTransparency = 1
        BindContainer.Size = UDim2.new(1, 0, 0, 50)
        BindContainer.Position = UDim2.new(0, 0, 0, yOffset)
        BindContainer.ZIndex = 5
        BindContainer.Visible = true
        
        -- "Bind" text on top (centered exactly above the input box)
        local BindTopLabel = Instance.new("TextLabel")
        BindTopLabel.Name = "BindTopLabel"
        BindTopLabel.Parent = BindContainer
        BindTopLabel.BackgroundTransparency = 1
        BindTopLabel.Position = UDim2.new(0.085, 0, 0, 0)
        BindTopLabel.Size = UDim2.new(0, 60, 0, 15) -- Width matches bind frame
        BindTopLabel.Font = Enum.Font.SourceSans
        BindTopLabel.Text = "Bind"
        BindTopLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
        BindTopLabel.TextSize = 12
        BindTopLabel.TextXAlignment = Enum.TextXAlignment.Center
        BindTopLabel.ZIndex = 6
        
        -- Main bind frame (width 60px)
        local BindFrame = Instance.new("TextButton")
        BindFrame.Name = "BindFrame"
        BindFrame.Parent = BindContainer
        BindFrame.BackgroundColor3 = Color3.fromRGB(25, 28, 34)
        BindFrame.BorderSizePixel = 0
        BindFrame.Position = UDim2.new(0.085, 0, 0, 15)
        BindFrame.Size = UDim2.new(0, 60, 0, 30)
        BindFrame.AutoButtonColor = false
        BindFrame.Text = ""
        BindFrame.ZIndex = 6
        
        local UICornerBind = Instance.new("UICorner")
        UICornerBind.CornerRadius = UDim.new(0, 4)
        UICornerBind.Parent = BindFrame
        
        -- Text inside bind frame
        local BindTextLabel = Instance.new("TextLabel")
        BindTextLabel.Name = "BindText"
        BindTextLabel.Parent = BindFrame
        BindTextLabel.BackgroundTransparency = 1
        BindTextLabel.Size = UDim2.new(1, 0, 1, 0)
        BindTextLabel.Font = Enum.Font.SourceSans
        BindTextLabel.Text = defaultKey and tostring(defaultKey.Name) or "..."
        BindTextLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
        BindTextLabel.TextSize = 14
        BindTextLabel.TextXAlignment = Enum.TextXAlignment.Center
        BindTextLabel.ZIndex = 7
        BindTextLabel.ClipsDescendants = true
        
        -- Bind name (with 10px offset from BindFrame)
        local BindNameLabel = Instance.new("TextLabel")
        BindNameLabel.Name = "BindName"
        BindNameLabel.Parent = BindContainer
        BindNameLabel.BackgroundTransparency = 1
        BindNameLabel.Position = UDim2.new(0.085, 70, 0, 15) -- 60 (width) + 10 (offset)
        BindNameLabel.Size = UDim2.new(0, 100, 0, 30)
        BindNameLabel.Font = Enum.Font.SourceSansBold
        BindNameLabel.Text = bindName
        BindNameLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
        BindNameLabel.TextTransparency = 0
        BindNameLabel.TextSize = 15
        BindNameLabel.TextXAlignment = Enum.TextXAlignment.Left
        BindNameLabel.ZIndex = 6
        
        local currentKey = defaultKey
        local listening = false
        local keyConnection = nil
        
        local function updateBindText()
            BindTextLabel.Text = currentKey and tostring(currentKey.Name) or "..."
            
            if save and self._saveConfig.enabled then
                pcall(function()
                    saveBindState(self, bindName, currentKey and currentKey.Name or nil)
                end)
            end
        end
        
        local function onKeyPressed(input, gameProcessed)
            if gameProcessed then return end
            
            if input.UserInputType == Enum.UserInputType.Keyboard then
                if input.KeyCode == currentKey then
                    pcall(callback, currentKey.Name)
                end
            end
        end
        
        local function startListening()
            listening = true
            BindTextLabel.Text = "..."
            
            if keyConnection then
                keyConnection:Disconnect()
            end
            
            local connection
            connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                
                -- Ignore mouse clicks
                if input.UserInputType == Enum.UserInputType.MouseButton1 or 
                   input.UserInputType == Enum.UserInputType.MouseButton2 or
                   input.UserInputType == Enum.UserInputType.MouseButton3 then
                    return
                end
                
                -- Get the key
                local newKey
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    newKey = input.KeyCode
                else
                    newKey = input.UserInputType
                end
                
                currentKey = newKey
                listening = false
                connection:Disconnect()
                updateBindText()
                
                -- Reconnect key listener
                if keyConnection then
                    keyConnection:Disconnect()
                end
                keyConnection = UserInputService.InputBegan:Connect(onKeyPressed)
            end)
        end
        
        BindFrame.MouseButton1Click:Connect(function()
            if not listening then
                startListening()
            end
        end)
        
        -- Initialize key listener if we have a default key
        if currentKey then
            if keyConnection then
                keyConnection:Disconnect()
            end
            keyConnection = UserInputService.InputBegan:Connect(onKeyPressed)
        end
        
        updateBindText()
        
        table.insert(self._bindElements, BindContainer)

        -- Update section sizes
        task.defer(function()
            local currentElements = getSortedElements(ContentFrame)
            local totalHeight = 0
            
            if #currentElements > 0 then
                local lastElement = currentElements[#currentElements]
                totalHeight = lastElement.Position.Y.Offset + lastElement.Size.Y.Offset
            end
            
            if windowInstance._sectionStates[section] then
                ContentFrame.Size = UDim2.new(1, 0, 0, totalHeight + 5)
                section.Size = UDim2.new(1, 0, 0, 30 + totalHeight + 15)
            end
            
            local sectionsList = table.find(self._leftSections, section) and self._leftSections or self._rightSections
            local container = sectionsList == self._leftSections and LeftContainer or RightContainer
            updateSectionPositions(container, sectionsList)
        end)
        
        return {
            Set = function(self, value)
                if type(value) == "string" then
                    value = Enum.KeyCode[value:upper()] or nil
                end
                
                currentKey = value
                updateBindText()
                
                -- Update key listener
                if keyConnection then
                    keyConnection:Disconnect()
                end
                if currentKey then
                    keyConnection = UserInputService.InputBegan:Connect(onKeyPressed)
                end
            end,
            Get = function(self)
                return currentKey and currentKey.Name or nil
            end
        }
    end

    local function updateAllDropdownPositions()
        for dropdownContainer, dropdownList in pairs(windowInstance._openDropdowns) do
            local button = dropdownContainer:FindFirstChild("Button")
            if button then
                local buttonPos = button.AbsolutePosition
                local buttonSize = button.AbsoluteSize
                local screenSize = ScreenGui.AbsoluteSize
                local maxHeight = math.min(4, #dropdownContainer.options or 4) * 20
                
                local yPos = buttonPos.Y + buttonSize.Y
                if yPos + maxHeight > screenSize.Y then
                    yPos = buttonPos.Y - maxHeight
                end
                
                dropdownList.Position = UDim2.new(0, buttonPos.X, 0, yPos)
            end
        end
    end

    return windowInstance
end

return PizdecWare
